<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · IBPM</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IBPM</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-Problem"><span>Defining the Problem</span></a></li><li><a class="tocitem" href="#Basic-Callbacks"><span>Basic Callbacks</span></a></li><li><a class="tocitem" href="#Quantities"><span>Quantities</span></a></li><li><a class="tocitem" href="#Saving-Results"><span>Saving Results</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Grid-Quantities"><span>Grid Quantities</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/experimental/sfd/">sfd.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">fluid-domain</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/fluid-domain/fluid-domain/">fluid-domain.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">fluid-operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/fluid-operators/curl/">curl.jl</a></li><li><a class="tocitem" href="../../manual/fluid-operators/dst-inversion/">dst-inversion.jl</a></li><li><a class="tocitem" href="../../manual/fluid-operators/laplacian/">laplacian.jl</a></li><li><a class="tocitem" href="../../manual/fluid-operators/mg-utils/">mg-utils.jl</a></li><li><a class="tocitem" href="../../manual/fluid-operators/nonlinear/">nonlinlear.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">interface-coupling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/interface-coupling/interface-coupling/">interface-coupling.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">plotting</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/plotting/plotting-utils/">plotting-utils.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">pre-processing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/pre-processing/models/">models.jl</a></li><li><a class="tocitem" href="../../manual/pre-processing/problem-types/">problem-types.jl</a></li><li><a class="tocitem" href="../../manual/pre-processing/state-types/">state-types.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">structure-domain</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/structure-domain/body-types/">body-types.jl</a></li><li><a class="tocitem" href="../../manual/structure-domain/motion-types/">motion-types.jl</a></li><li><a class="tocitem" href="../../manual/structure-domain/move-body-utils/">move-body-utils.jl</a></li><li><a class="tocitem" href="../../manual/structure-domain/sample-bodies/">sample-bodies.jl</a></li><li><a class="tocitem" href="../../manual/structure-domain/structure-domain/">structure-domain.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">timestepping</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/timestepping/quantities/">quantities.jl</a></li><li><a class="tocitem" href="../../manual/timestepping/solve/">solve.jl</a></li><li><a class="tocitem" href="../../manual/timestepping/timestepping/">timestepping.jl</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nick4f42/IBPM.jl/blob/main/docs/src/getting-started/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial:-Double-Cylinders"><a class="docs-heading-anchor" href="#Tutorial:-Double-Cylinders">Tutorial: Double Cylinders</a><a id="Tutorial:-Double-Cylinders-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-Double-Cylinders" title="Permalink"></a></h1><p>In this example, we will simulate the flow past two rigid cylinders. The general workflow is:</p><ul><li>Define the problem<ul><li>Grid</li><li>Bodies</li><li>Freestream velocity</li><li>Reynold&#39;s number</li><li>Time step</li></ul></li><li>Define callbacks</li><li>Solve the problem</li></ul><h2 id="Defining-the-Problem"><a class="docs-heading-anchor" href="#Defining-the-Problem">Defining the Problem</a><a id="Defining-the-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Problem" title="Permalink"></a></h2><pre><code class="language-julia hljs">using IBPM</code></pre><p>The first step is to define the grid.</p><pre><code class="language-julia hljs">xlim = (-1.0, 3.0) # x bounds
ylim = (-2.0, 2.0) # y bounds
dx = 0.02          # Grid step size
mg = 3             # Number of subdomains
mgrid = MultiGrid(dx, (xlim, ylim); mg=mg)</code></pre><p><code>MultiGrid</code> specifies multiple grids overlayed on top of each other. The x and y limits specify the smallest grid, and each grid is twice the side length as the previous.</p><p>Next, we define the bodies. In this case, we will specify two cylinders of radius <code>0.5</code>. The <a href="getting-started/@ref"><code>IBPM.Bodies</code></a> module contains various default bodies, including a cylinder.</p><pre><code class="language-julia hljs">using IBPM.Bodies

r = 0.5
bodies = [
    Bodies.cylinder((0.0, -1.0), r, dx)
    Bodies.cylinder((0.0, +1.0), r, dx)
]</code></pre><p>To specify arbitary bodies, see <a href="getting-started/@ref"><code>RigidBody</code></a>.</p><p>Then, the remaining quantities are specified and the <a href="../../manual/pre-processing/problem-types/#IBPM.IBProblem"><code>IBProblem</code></a> is constructed.</p><pre><code class="language-julia hljs"># Freestream velocity
freestream(t) = (1.0, 0.0)

Re = 100.0 # Reynolds number
dt = 0.004 # Time step size

prob = IBProblem(mgrid, bodies, freestream; Re=Re, dt=dt)</code></pre><p>The <a href="../../manual/timestepping/solve/#IBPM.solve-Tuple{Any, Any}"><code>solve</code></a> function solves the problem. By default, no results are displayed or returned. In order to get results, you must use a callback.</p><h2 id="Basic-Callbacks"><a class="docs-heading-anchor" href="#Basic-Callbacks">Basic Callbacks</a><a id="Basic-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Callbacks" title="Permalink"></a></h2><p>During the simulation, the current state is stored in a <a href="../../manual/pre-processing/state-types/#IBPM.IBState-Tuple{Any, Number}"><code>IBState</code></a> struct. The <a href="../../manual/timestepping/solve/#IBPM.StateCallback"><code>StateCallback</code></a> type can be used to retrieve information about this state. State callbacks can be constructed with the <a href="../../manual/timestepping/solve/#IBPM.each_timestep-Tuple{Any, Vararg{Any}}"><code>each_timestep</code></a>, <a href="../../manual/timestepping/solve/#IBPM.at_times-Tuple{Any, Any, Vararg{Any}}"><code>at_times</code></a>, or <a href="../../manual/timestepping/solve/#IBPM.at_indices-Tuple{Any, Any, Vararg{Any}}"><code>at_indices</code></a> functions.</p><p>For example, to print the current simulation time at each timestep:</p><pre><code class="language-julia hljs">f(state) = println(&quot;t = &quot;, state.t) # show the state&#39;s time
printer = each_timestep(f)</code></pre><p>Or, using Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/functions/#Do-Block-Syntax-for-Function-Arguments">do block syntax</a>:</p><pre><code class="language-julia hljs">printer = each_timestep() do state
    println(&quot;t = &quot;, state.t) # show the state&#39;s time
end</code></pre><p>Now, you can run the simulation over the time range <code>(0.0, 1.0)</code> and execute the callback with:</p><pre><code class="language-julia-repl hljs">julia&gt; solve(prob, (0.0, 1.0); call=[printer])
t = 0.0
t = 0.004
t = 0.008
t = 0.012
t = 0.016
...
t = 0.984
t = 0.988
t = 0.992
t = 0.996
t = 1.0
()</code></pre><p>In order to run a callback at certain times, you can <a href="../../manual/timestepping/solve/#IBPM.at_times-Tuple{Any, Any, Vararg{Any}}"><code>at_times</code></a>. Note that the specified times are rounded to the nearest timestep. </p><pre><code class="language-julia hljs">printer = at_times([0.1, 0.5, 0.75]) do state
    println(&quot;t = &quot;, state.t)
end</code></pre><pre><code class="language-julia-repl hljs">julia&gt; solve(prob, (0.0, 1.0); call=[printer])
t = 0.1
t = 0.5
t = 0.752
()</code></pre><p>Any amount of <a href="../../manual/timestepping/solve/#IBPM.StateCallback"><code>StateCallback</code></a>s can be passed to <code>solve</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; foo = at_times([0.0, 0.5]) do state
           println(&quot;foo &quot;, state.t)
       end;

julia&gt; bar = at_times(0.2:0.1:0.7) do state
           println(&quot;bar &quot;, state.t)
       end;

julia&gt; solve(prob, (0.0, 1.0); call=[foo, bar])
foo 0.0
bar 0.2
bar 0.3
bar 0.4
foo 0.5
bar 0.5
bar 0.6
bar 0.7
()</code></pre><h2 id="Quantities"><a class="docs-heading-anchor" href="#Quantities">Quantities</a><a id="Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Quantities" title="Permalink"></a></h2><p>The <a href="getting-started/@ref"><code>Quantities</code></a> module provides functions to retrieve various quantities from the state. For example, the lift and drag coefficients:</p><pre><code class="language-julia hljs">using IBPM.Quantities

# Initialize lift and drag functions for the current problem
lift_coef = LiftCoef(prob)
drag_coef = DragCoef(prob)</code></pre><p><code>lift_coef</code> and <code>drag_coef</code> are now functions of <code>state</code>. We can use them in a callback to display the lift and drag coefficients at various times:</p><pre><code class="language-julia hljs">printer = at_times([0.4, 0.5, 0.6]) do state
    t = state.t
    CL = lift_coef(state)
    CD = drag_coef(state)
    
    @show t CL CD # show the time, lift, and drag
    println() # add a blank line
end;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; solve(prob, (0.0, 1.0); call=[printer])
t = 0.4
CL = [0.15178098433850362, -0.15178098294484957]
CD = [1.9657374042287432, 1.9657374049036318]

t = 0.5
CL = [0.09809539226174821, -0.0980953807487285]
CD = [1.9616546848510217, 1.9616546911652222]

t = 0.6
CL = [0.0338480211407524, -0.03384797778806221]
CD = [1.9843193605706249, 1.9843193890137298]

()</code></pre><p>Note that <code>lift_coef</code> and <code>drag_coef</code> return arrays of values, one for each body specified.</p><h2 id="Saving-Results"><a class="docs-heading-anchor" href="#Saving-Results">Saving Results</a><a id="Saving-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Results" title="Permalink"></a></h2><p>Each time we called <code>solve</code>, it returned the empty tuple <code>()</code>. This is because we did not specify any quantities to save. We can specify callbacks to save with the <code>save</code> keyword argument. Any return values from the given <a href="../../manual/timestepping/solve/#IBPM.StateCallback"><code>StateCallback</code></a>s are aggregated during the simulation.</p><pre><code class="language-julia-repl hljs">julia&gt; state_time = at_times([0.0, 0.1, 0.5]) do state
           return state.t
       end;

julia&gt; solve(prob, (0.0, 1.0); save=())
()

julia&gt; solve(prob, (0.0, 1.0); save=(state_time,))
([0.0, 0.1, 0.5],)</code></pre><p>By default, the result array has element type <code>Any</code>. To specify the type of values returned by a callback, pass it as an additional argument:</p><pre><code class="language-julia-repl hljs">julia&gt; state_time = at_times([0.0, 0.1, 0.5], Float64) do state
           return state.t
       end;

julia&gt; times, = solve(prob, (0.0, 1.0); save=(state_time,))
([0.0, 0.1, 0.5],)

julia&gt; eltype(times)
Float64</code></pre><p>Using the <code>lift_coef</code> and <code>drag_coef</code> functions defined earlier, we can save the lift and drag:</p><pre><code class="language-julia hljs">get_lift = at_times(0.1:0.3:1, Float64) do state
    return lift_coef(state)[1] # get the lift coefficient of the first body
end
get_drag = at_times(0.1:0.3:1, Float64) do state
    return drag_coef(state)[1] # get the drag coefficient of the first body
end</code></pre><pre><code class="language-julia-repl hljs">julia&gt; (CL, CD) = solve(prob, (0.0, 1.0); save=(get_lift, get_drag));

julia&gt; CL
4-element IBPM.StateResult{Float64}:
  0.24192790813515172
  0.15178098433850362
 -0.03935393884308133
 -0.29355757293462786

julia&gt; CD
4-element IBPM.StateResult{Float64}:
 2.780251707849143
 1.9657374042287432
 2.017601519175688
 2.105254970163017</code></pre><p>If you are saving multiple quantities, you can use a named tuple to keep track of the fields.</p><pre><code class="language-julia hljs">save = (
    time=at_times(state -&gt; state.t, [0.1, 0.2], Float64),
    lift=at_times(state -&gt; lift_coef(state)[1], [0.3, 0.4], Float64),
    drag=at_times(state -&gt; drag_coef(state)[1], [0.3, 0.4], Float64),
)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; results = solve(prob, (0.0, 1.0); save=save)
(time = [0.1, 0.2], lift = [0.1937292945096216, 0.15178098433850362], drag = [2.0271052799736538, 1.9657374042287432])

julia&gt; results.drag[2]
1.9657374042287432</code></pre><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>IBPM comes with two built-in plotting recipes for the <a href="https://docs.juliaplots.org/stable/"><code>Plots</code></a> package: <a href="getting-started/@ref"><code>fluidplot</code></a> and <a href="getting-started/@ref"><code>bodyplot</code></a>. The former is essentially a heatmap with sensible defaults, and the latter plots bodies.</p><pre><code class="language-julia hljs">using Plots</code></pre><p>To plot some function or array over a range of x coordinates <code>x</code> and y coordinates <code>y</code>, the syntax is:</p><pre><code class="language-julia hljs">fluidplot(x, y, f)</code></pre><p>Keyword arguments are interpreted by <code>Plots</code>, so you can do something like:</p><pre><code class="language-julia hljs">fluidplot(x, y, f; colorbar=false, title=&quot;foo&quot;)</code></pre><p>To plot a body, the syntax is</p><pre><code class="language-julia hljs">bodyplot(points)</code></pre><p>You can easily get <code>points</code> with the <a href="getting-started/@ref"><code>BodyPoints</code></a> quantity from <a href="getting-started/@ref"><code>IBPM.Quantities</code></a> module.</p><pre><code class="language-julia hljs">using IBPM.Quantities

vorticity = Vorticity(prob)
bodypoints = BodyPoints(prob)

T = 5.0
the_last_state = at_times(identity, [T])
(last_state,), = solve(prob, (0.0, T); save=(the_last_state,))

x = range(-1, 3, step=dx)
y = range(-2, 2, step=dx)

fluidplot(x, y, vorticity(last_state))
bodyplot!(bodypoints(last_state)) # modify the plot (!)</code></pre><p><img src="../../assets/double_cyl_plot.png" alt="Vorticity Contour Plot"/></p><p>A simple animation can be made with Plots&#39; <a href="https://docs.juliaplots.org/latest/animations/#animations"><code>Animation</code></a>.</p><pre><code class="language-julia hljs">T = 15.0
anim = Animation()

save_anim = at_times(range(0, T, 150)) do state
    fluidplot(x, y, vorticity(state); clims=(-5, 5), size=(512, 512))
    bodyplot!(bodypoints(state))
    
    frame(anim) # Save an animation frame
end

solve(prob, (0.0, T); call=[save_anim])

gif(anim)</code></pre><p><img src="../../assets/double_cyl_anim.gif" alt="Vorticity Animation"/></p><h2 id="Grid-Quantities"><a class="docs-heading-anchor" href="#Grid-Quantities">Grid Quantities</a><a id="Grid-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Quantities" title="Permalink"></a></h2><p>By default, quantities that apply over a grid like <code>Vorticity</code> return interpolation functions. To get the raw arrays, specify <code>kind=Discrete()</code> as a keyword argument:</p><pre><code class="language-julia-repl hljs">julia&gt; grid_vorticity = Vorticity(prob; kind=Discrete());

julia&gt; grid_vorticity(last_state)
199×199×3 Array{Float64, 3}:
[:, :, 1] =
 1.45597e-14  …  -1.41273e-14
 1.4306e-14      -1.33512e-14
 1.38929e-14     -1.27107e-14
 ⋮            ⋱  
 0.00363365      -0.00385906
 0.00305794      -0.00338663

[:, :, 2] =
 -1.10463e-14  …  1.05124e-14
 -1.2348e-14      1.18209e-14
 -1.19748e-14     1.14585e-14
  ⋮            ⋱  
 -1.06824e-14     1.55079e-14
 -1.03108e-14     1.50663e-14

[:, :, 3] =
  8.24782e-16  …  -7.9071e-16
 -6.53323e-16      7.31455e-16
 -2.35906e-15      2.34558e-15
  ⋮            ⋱  
  9.93147e-15     -9.60593e-15
  1.77592e-14     -1.81424e-14</code></pre><p>The last dimension corresponds to the 3 subdomains we specified earlier. To get the coordinates that these values apply to, see <a href="getting-started/@ref"><code>gridranges</code></a>.</p><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><p>There are more examples in the <code>examples</code> directory of the <code>IBPM</code> repository. Among other things, they show how to specify moving bodies.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../../manual/experimental/sfd/">sfd.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Tuesday 19 July 2022 15:54">Tuesday 19 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
