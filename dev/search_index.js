var documenterSearchIndex = {"docs":
[{"location":"manual/timestepping/timestepping/","page":"timestepping.jl","title":"timestepping.jl","text":"Modules = [IBPM]\nPages = [\"timestepping.jl\"]","category":"page"},{"location":"manual/timestepping/timestepping/#IBPM.advance!-Tuple{IBPM.IBState, IBPM.AbstractIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.advance!","text":"advance!(state::IBState, prob::AbstractIBProblem, t::Float64)\n\nAdvance state forward in time.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.advance!-Tuple{IBPM.IBState, IBPM.IBState, IBPM.AbstractIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.advance!","text":"advance!(y::IBState, x::IBState, prob::AbstractIBProblem, t::Float64)\n\nAdvance state x forward in time and save in y\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.advance-Tuple{IBPM.IBState, IBPM.AbstractIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.advance","text":"advance(x::IBState, prob::AbstractIBProblem, t::Float64)\n\nAdvance state x forward in time (not mutating)\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.base_flux!-Tuple{IBPM.IBState, IBPM.AbstractIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.base_flux!","text":"base_flux!(state::IBState, prob::AbstractIBProblem, t::Float64)\n\nSet background flux based on prob.model.bodies[].motion\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.base_flux!-Tuple{Type{IBPM.MovingGrid}, IBPM.IBState, IBProblem, Float64}","page":"timestepping.jl","title":"IBPM.base_flux!","text":"Update time-varying background flux for moving grid\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.base_flux!-Tuple{Type{IBPM.Static}, IBPM.IBState, IBPM.LinearizedIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.base_flux!","text":"Freestream flux for linearized problem (uniform zero)\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.base_flux!-Tuple{Type{T} where T<:IBPM.InertialMotion, IBPM.IBState, IBProblem, Float64}","page":"timestepping.jl","title":"IBPM.base_flux!","text":"Initialize irrotational freestream flux when not time-varying\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.boundary_forces!-NTuple{4, Any}","page":"timestepping.jl","title":"IBPM.boundary_forces!","text":"boundary_forces!(F̃b, qs, q0, prob)\n\nSolve the Poisson equation (25) in Colonius & Taira (2008).\n\nDispatch based on the type of motion in the problem - allows precomputing regularization and interpolation where possible.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.boundary_forces!-Tuple{Type{V} where V<:IBPM.Motion, Any, Any, Any, Any}","page":"timestepping.jl","title":"IBPM.boundary_forces!","text":"boundary_forces!(::Type{V} where V <: Motion, F̃b, qs, q0, prob)\n\nSolve the Poisson problem for bc2 = 0 (???) with nonzero boundary velocity ub\n\nBf̃ = Eq - ub\n   = ECψ - ub\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.boundary_forces!-Tuple{Union{Type{IBPM.MovingGrid}, Type{IBPM.Static}}, Any, Any, Any, Any}","page":"timestepping.jl","title":"IBPM.boundary_forces!","text":"boundary_forces!(::Union{Type{Static}, Type{MovingGrid}},\n                 F̃b, qs, q0, prob)\n\nSolve modified Poisson problem for uB = 0 and bc2 = 0\n\n Bf̃ = Eq = ECψ\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.get_trial_state!-Tuple{AbstractArray, AbstractArray, IBPM.IBState, IBPM.AbstractIBProblem}","page":"timestepping.jl","title":"IBPM.get_trial_state!","text":"get_trial_state!(qs, Γs, state, prob)\n\nCompute trial circulation Γs that doesn't satisfy no-slip BCs\n\nCombine explicit Laplacian and nonlinear terms into a rhs then invert implicit part to return trial circulation Γs\n\nHigh-level version of AB2: rhs = AΓ .-       3dt/2 * nonlin .+       dt/2 * nonlin_prev .+       dt/2 * rhsbc\n\nThen do Ainv of that to back out trial circ\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.project_circ!-Tuple{AbstractArray, IBPM.IBState, IBPM.AbstractIBProblem}","page":"timestepping.jl","title":"IBPM.project_circ!","text":"project_circ!(Γs, state, prob)\n\nUpdate circulation to satisfy no-slip condition.\n\nDispatch based on the type of motion in the problem.\n\nThis allows precomputing regularization and interpolation where possible.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.update_bodies!-Tuple{IBPM.IBState, IBPM.AbstractIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.update_bodies!","text":"update_bodies!(prob, t)\n\nUpdate the immersed bodies and coupling matrices (if applicable).\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.update_bodies!-Tuple{Type{IBPM.MotionFunction}, IBPM.IBState, IBProblem, Float64}","page":"timestepping.jl","title":"IBPM.update_bodies!","text":"For moving grid, update the bodies and the coupling operators\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.update_bodies!-Tuple{Union{Type{IBPM.MovingGrid}, Type{IBPM.Static}}, IBPM.IBState, IBPM.AbstractIBProblem, Float64}","page":"timestepping.jl","title":"IBPM.update_bodies!","text":"No motion for static or moving grid cases \n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/timestepping/#IBPM.update_stress!-Tuple{IBPM.IBState, IBPM.AbstractIBProblem}","page":"timestepping.jl","title":"IBPM.update_stress!","text":"update_stress!(state, prob)\n\nStore surface stresses and integrated forces.\n\nMutates \"state\"\n\n\n\n\n\n","category":"method"},{"location":"manual/experimental/sfd/","page":"sfd.jl","title":"sfd.jl","text":"Modules = [IBPM]\nPages = [\"sfd.jl\"]","category":"page"},{"location":"manual/structure-domain/move-body-utils/","page":"move-body-utils.jl","title":"move-body-utils.jl","text":"Modules = [IBPM]\nPages = [\"move-body-utils.jl\"]","category":"page"},{"location":"manual/structure-domain/move-body-utils/#IBPM.MotionType-Tuple{IBPM.Body}","page":"move-body-utils.jl","title":"IBPM.MotionType","text":"Type (1): low-level functions\n\n\n\n\n\n","category":"method"},{"location":"manual/structure-domain/move-body-utils/#IBPM.move_body!-Tuple{IBPM.RigidBody, Float64}","page":"move-body-utils.jl","title":"IBPM.move_body!","text":"Type (3): the main driver functions that implement prescribed body motion\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/solve/","page":"solve.jl","title":"solve.jl","text":"Modules = [IBPM]\nPages = [\"solve.jl\"]","category":"page"},{"location":"manual/timestepping/solve/#IBPM.AllTimesteps","page":"solve.jl","title":"IBPM.AllTimesteps","text":"AllTimesteps() :: Timesteps\n\nSpecifies all the timesteps during a simulation.\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.StateCallback","page":"solve.jl","title":"IBPM.StateCallback","text":"StateCallback(f, timesteps::Timesteps, ret::Type=Any)\n\nSpecifies a callback f(state) that should be run at the given timesteps.\n\nIt is recommended to use each_timestep, at_times, or at_indices to construct this type. The return type of f can be specified with ret. The value of ret determines the type of StateResult that a callback is mapped to.\n\nCan be passed to solve to specify callbacks and results.\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.StateResult","page":"solve.jl","title":"IBPM.StateResult","text":"StateResult{T} <: AbstractVector{T}\n\nThe congregated results from a StateCallback. T is determined by the ret argument to StateCalllback.\n\nThe t field stores the time corresponding to each data entry. result[i] was taken at simulation time result.t[i].\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.StopIteration","page":"solve.jl","title":"IBPM.StopIteration","text":"StopIteration\n\nSentinel returned by a StateCallback that indicates that solve should terminate.\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.TimestepIndices","page":"solve.jl","title":"IBPM.TimestepIndices","text":"TimestepIndices(i) :: Timesteps\n\nSpecifies certain timestep indices during a simulation.\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.TimestepTimes","page":"solve.jl","title":"IBPM.TimestepTimes","text":"TimestepTimes(t) :: Timesteps\n\nSpecifies certain times during a simulation.\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.Timesteps","page":"solve.jl","title":"IBPM.Timesteps","text":"Timesteps\n\nSpecifies certain timesteps during a simulation.\n\n\n\n\n\n","category":"type"},{"location":"manual/timestepping/solve/#IBPM.at_indices-Tuple{Any, Any, Vararg{Any}}","page":"solve.jl","title":"IBPM.at_indices","text":"at_indices(f, i, [ret]) :: StateCallback\n\nReturn a StateCallback that runs f(state) at the n'th timestep for each n in i.\n\nret specifies the return type of f.\n\nSee also each_timestep, at_times.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/solve/#IBPM.at_times-Tuple{Any, Any, Vararg{Any}}","page":"solve.jl","title":"IBPM.at_times","text":"at_times(f, t, [ret]) :: StateCallback\n\nReturn a StateCallback that runs f(state) at each time in t.\n\nret specifies the return type of f.\n\nSee also each_timestep, at_indices.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/solve/#IBPM.compute_cfl-Tuple{Any, Any}","page":"solve.jl","title":"IBPM.compute_cfl","text":"compute_cfl(state, prob)\n\nCompute the CFL number (uΔt/Δx) based on the fine-grid flux.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/solve/#IBPM.each_timestep-Tuple{Any, Vararg{Any}}","page":"solve.jl","title":"IBPM.each_timestep","text":"each_timestep(f, [ret]) :: StateCallback\n\nReturn a StateCallback that runs f(state) at each timestep.\n\nret specifies the return type of f.\n\nSee also at_times, at_indices.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/solve/#IBPM.solve!-Tuple{IBPM.IBState, IBProblem, Any}","page":"solve.jl","title":"IBPM.solve!","text":"solve!(state, problem, (t0, tf); [save], [call]) -> results\n\nSolve problem between times t0 and tf by overwriting state each iteration.\n\nSee also solve.\n\n\n\n\n\n","category":"method"},{"location":"manual/timestepping/solve/#IBPM.solve-Tuple{Any, Any}","page":"solve.jl","title":"IBPM.solve","text":"solve(problem, (t0, tf); [save], [call]) -> results\n\nSolve problem between times t0 and tf, optionally saving or executing callbacks.\n\nArguments\n\nproblem::IBProblem: The problem specification.\n(t0, tf): Initial and final times.\nsave: Collection of StateCallback that maps to results (default is empty).\ncall: Collection of StateCallback to be executed during the simulation.\n\nReturns\n\nThe result of mapping each callback in save to a StateResult using map.\n\n\n\n\n\n","category":"method"},{"location":"manual/structure-domain/sample-bodies/","page":"sample-bodies.jl","title":"sample-bodies.jl","text":"Modules = [IBPM]\nPages = [\"sample-bodies.jl\"]","category":"page"},{"location":"manual/structure-domain/body-types/","page":"body-types.jl","title":"body-types.jl","text":"Modules = [IBPM]\nPages = [\"body-types.jl\"]","category":"page"},{"location":"manual/structure-domain/body-types/#IBPM.Body","page":"body-types.jl","title":"IBPM.Body","text":"Body types\n\nSee structure-domain/sample-bodies.jl for examples of constructing these\n\nMOVE TO structure-domain???\n\n\n\n\n\n","category":"type"},{"location":"manual/fluid-operators/curl/","page":"curl.jl","title":"curl.jl","text":"Modules = [IBPM]\nPages = [\"curl.jl\"]","category":"page"},{"location":"manual/fluid-operators/curl/#IBPM.curl!-Tuple{Any, Any, Any, MultiGrid}","page":"curl.jl","title":"IBPM.curl!","text":"curl!( q, ψ, ψbc, grid )\n\nCompute velocity flux from streamfunction on MultiGrid.\n\nNote: requires streamfunction from coarser grid on edge        of current domain (stored in ψbc)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/curl/#IBPM.curl!-Tuple{Any, Any, Any}","page":"curl.jl","title":"IBPM.curl!","text":"curl!( q, ψ, grid )\n\nDiscrete curl operator\n\nq = curl( ψ )\n\nThis is wrapped into a LinearMap, so call with\n\nq = C * ψ\n\nwhere C is in the IBMatrices struct.  Note that this doesn't actualy get    used in the MultiGrid formulation, but it is the adjoint to rot, which    does get called.  See below for the MultiGrid version of curl.\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/curl/#IBPM.rot!-NTuple{4, Any}","page":"curl.jl","title":"IBPM.rot!","text":"rot!( Γ, q, grid )\n\nTranspose of discrete curl (R matrix in previous versions of the code)\n\nΓ = rot( q )\n\nΓwork should be (nx-1)×(ny-1)... this is preallocated in IBMatrices and wrapped into a LinearMap, so just call with\n\nΓ = C'*q\n\nwhere C is in the IBMatrices struct\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/curl/#IBPM.vort2flux!-Tuple{Any, Any, Any, IBPM.IBModel{MultiGrid}, Int64}","page":"curl.jl","title":"IBPM.vort2flux!","text":"vort2flux!( ψ, q, Γ, model, ngrids )\n\n!***************************************************************! !*    Multiscale method to solve C^T C s = omega               ! !    and return the velocity, C s.                            ! !    Results are returned in vel on each of the first nlev    ! !    grids.                                                   ! !    Warning: the vorticity field on all but the finest mesh  ! !     is modified by the routine in the following way:        ! !     the value in the center of the domain is interpolated   ! !     from the next finer mesh (the value near the edge is    ! !     not changed.                                            *! !***************************************************************!\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/dst-inversion/","page":"dst-inversion.jl","title":"dst-inversion.jl","text":"Modules = [IBPM]\nPages = [\"dst-inversion.jl\"]","category":"page"},{"location":"manual/pre-processing/models/","page":"models.jl","title":"models.jl","text":"Modules = [IBPM]\nPages = [\"models.jl\"]","category":"page"},{"location":"manual/pre-processing/models/#IBPM.AdamsBashforth","page":"models.jl","title":"IBPM.AdamsBashforth","text":"AdamsBashforth <: ExplicitScheme\n\nThe group of multistep methods known as Adams-Bashforth methods. Currently supports:\n\nTwo step Adams-Bashforth Method\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/models/#IBPM.ExplicitScheme","page":"models.jl","title":"IBPM.ExplicitScheme","text":"A collection of different explicit time stepping schemes. Types of explicit schemes include:\n\nAdamsBashforth\nTODO: RungeKuttaChebyshev\n\nIs passed as an arugment into IBProblem, see Main.IBPM.IBProblem.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/models/#IBPM.IBMatrices","page":"models.jl","title":"IBPM.IBMatrices","text":"Matrices that can be precomputed\n\nCorrespondence with Taira & Colonius (2007)     Note that not all matrices defined here are explicitly constructed C  - Basic curl operator for single-grid         Call curl! function for multigrid to take into account boundary conditions C' - Transforms velocity flux to circulation: Γ = C'q E  - Maps fluxes to body motion, i.e. u_B = Eq         Note that H = -E' is the regularization operator A  - Implicit time-stepping operator for velocity flux         A = I - (dt/2/h^2)*Lap\n\nNOTE: Most of the functionality for this is in fluid-operators/lin.jl\n\nConstructor\n\nIBMatrices(grid::Grid, bodies::Vector{<:Body})\n\nArguments\n\ngrid::Grid: Grid struct of type Grid which defines and discretizes the domain.\nbodies::Array{Body, 1}: 1D array of bodies created for simulation.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/models/#IBPM.IBModel","page":"models.jl","title":"IBPM.IBModel","text":"IBModel{T <: Grid, V <: Body} <: SolnModel\n\nContains information about simulation parameters and stores static matrices.  Is created using a type of grid, simulation bodies, Reynolds number, and freestream velocity. Is passed as an arugment into IBProblem, see Main.IBPM.IBProblem.\n\nConstructor\n\nIBModel(\n    grid::Grid,\n    bodies::Array{Body, 1},\n    Re::Number;\n    freestream::Function,\n    xc=0.0,\n    yc=0.0\n)\n\nArguments\n\ngrid::Grid: Grid struct of type Grid which defines and discretizes the domain.\nbodies::Array{Body, 1}: Array of bodies.\nRe::Number: Reynolds number.\nfreestream::Function: Free-stream velocity.\nxc=0.0: x coordinate offset for calculating rotational fluxes.\nyc=0.0: y coordinate offset for calculating rotational fluxes.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/models/#IBPM.SolnModel","page":"models.jl","title":"IBPM.SolnModel","text":"SolnModel contains information about simulation parameters and stores all static (non-time varying) matrices.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/models/#IBPM.WorkingMemory","page":"models.jl","title":"IBPM.WorkingMemory","text":"Pre-allocate memory to certain vectors that can be re-used throughout the computation process.\n\nConstructor\n\nWorkingMemory(grid::Grid)\n\nArguments\n\ngrid::Grid: Grid struct of type Grid which defines and discretizes the domain.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/models/#IBPM.AB2-Tuple{Float64}","page":"models.jl","title":"IBPM.AB2","text":"AB2(dt::Float64)\n\nSpecial case constructor for type::AdamsBashforth for second-order Adams-Bashforth scheme.\n\nArguments\n\ndt::Float64: Time stepping interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/laplacian/","page":"laplacian.jl","title":"laplacian.jl","text":"Modules = [IBPM]\nPages = [\"laplacian.jl\"]","category":"page"},{"location":"manual/fluid-operators/laplacian/#IBPM.get_Ainv-Tuple{IBPM.IBModel, Float64, Float64}","page":"laplacian.jl","title":"IBPM.get_Ainv","text":"Compute the matrix (as a LinearMap) that represents the modified Poisson operator (I + dt/2 * Beta * RC) arising from the implicit treatment of the Laplacian. A system involving this matrix is solved to compute a trial circulation that doesn't satisfy the BCs, and then again to use the surface stresses to update the trial circulation so that it satisfies the BCs\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/laplacian/#IBPM.get_Binv-Tuple{IBPM.IBModel{<:IBPM.Grid, IBPM.RigidBody{T}} where T<:IBPM.Motion, LinearMaps.LinearMap}","page":"laplacian.jl","title":"IBPM.get_Binv","text":"Precompute 'Binv' matrix by evaluating mat-vec products for unit vectors\n\nThis is a big speedup when the interpolation operator E isn't going to change (no FSI, for instance)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/laplacian/#IBPM.get_lap_inv-Union{Tuple{T}, Tuple{T, Matrix{Float64}, Tuple{Any, Matrix{Float64}}}} where T<:IBPM.Grid","page":"laplacian.jl","title":"IBPM.get_lap_inv","text":"Construct LinearMap to solve inverse problem with Laplacian\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/laplacian/#IBPM.lap_eigs-Tuple{T} where T<:IBPM.Grid","page":"laplacian.jl","title":"IBPM.lap_eigs","text":"Solving linear systems involving the Laplacian C^TC comes up in multiple places:     -backing out vel flux from circulation, done multiple times in a time step     -Solving a modified Poisson system (I + dt/2 * Beta * RC) that arises from         the implicit treatment of the Laplacian\n\nBoth of these systems can be solved efficiently (on uniform grids or nested     uniform grids) via FFTs. The three functions below enable the use of FFTs     to solve these linear systems (Lapeigs gives the eigenvalues of the matrix     and Λinvfn! provides a diagonalization via sine transforms),     and to save the action of the inverse operator efficiently as a LinearMap     (get_RCinv)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/mg-utils/","page":"mg-utils.jl","title":"mg-utils.jl","text":"Modules = [IBPM]\nPages = [\"mg-utils.jl\"]","category":"page"},{"location":"manual/fluid-operators/mg-utils/#IBPM.apply_bc!-NTuple{4, Any}","page":"mg-utils.jl","title":"IBPM.apply_bc!","text":"!***************************************************************! !*   given vorticity at edges of domain, rbc, (from larger,    ! !   coarser mesh), add values to correct laplacian of         ! !   vorticity  on the (smaller, finer) domain, r.             *! !***************************************************************!\n\nr is a vorticity-like array of size (nx-1)×(ny-1)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/mg-utils/#IBPM.coarsify!-Tuple{Any, Any, MultiGrid}","page":"mg-utils.jl","title":"IBPM.coarsify!","text":"!***************************************************************! !*   given vorticity on a smaller, fine mesh, (rhs) interp.    ! !   values to the center region of a larger, coarser mesh     ! !   (crhs).  The values outside the center region are         ! !   not unmodified. Result is placed in arhs                  *! !***************************************************************!\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/mg-utils/#IBPM.get_bc!-Tuple{Any, Any, Any}","page":"mg-utils.jl","title":"IBPM.get_bc!","text":"!***************************************************************! !*   given vorticity on a larger, coarser mesh, interpolate    ! !   it's values to the edge of a smaller, finer mesh          *! !***************************************************************!\n\n\n\n\n\n","category":"method"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = IBPM","category":"page"},{"location":"getting-started/tutorial/#Tutorial:-Double-Cylinders","page":"Tutorial","title":"Tutorial: Double Cylinders","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example, we will simulate the flow past two rigid cylinders. The general workflow is:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define the problem\nGrid\nBodies\nFreestream velocity\nReynold's number\nTime step\nDefine callbacks\nSolve the problem","category":"page"},{"location":"getting-started/tutorial/#Defining-the-Problem","page":"Tutorial","title":"Defining the Problem","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"using IBPM","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step is to define the grid.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"xlim = (-1.0, 3.0) # x bounds\nylim = (-2.0, 2.0) # y bounds\ndx = 0.02          # Grid step size\nmg = 3             # Number of subdomains\nmgrid = MultiGrid(dx, (xlim, ylim); mg=mg)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"MultiGrid specifies multiple grids overlayed on top of each other. The x and y limits specify the smallest grid, and each grid is twice the side length as the previous.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we define the bodies. In this case, we will specify two cylinders of radius 0.5. The IBPM.Bodies module contains various default bodies, including a cylinder.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"using IBPM.Bodies\n\nr = 0.5\nbodies = [\n    Bodies.cylinder((0.0, -1.0), r, dx)\n    Bodies.cylinder((0.0, +1.0), r, dx)\n]","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"To specify arbitary bodies, see RigidBody.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, the remaining quantities are specified and the IBProblem is constructed.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"# Freestream velocity\nfreestream(t) = (1.0, 0.0)\n\nRe = 100.0 # Reynolds number\ndt = 0.004 # Time step size\n\nprob = IBProblem(mgrid, bodies, freestream; Re=Re, dt=dt)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"The solve function solves the problem. By default, no results are displayed or returned. In order to get results, you must use a callback.","category":"page"},{"location":"getting-started/tutorial/#Basic-Callbacks","page":"Tutorial","title":"Basic Callbacks","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"During the simulation, the current state is stored in a IBState struct. The StateCallback type can be used to retrieve information about this state. State callbacks can be constructed with the each_timestep, at_times, or at_indices functions.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, to print the current simulation time at each timestep:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"f(state) = println(\"t = \", state.t) # show the state's time\nprinter = each_timestep(f)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Or, using Julia's do block syntax:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"printer = each_timestep() do state\n    println(\"t = \", state.t) # show the state's time\nend","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, you can run the simulation over the time range (0.0, 1.0) and execute the callback with:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> solve(prob, (0.0, 1.0); call=[printer])\nt = 0.0\nt = 0.004\nt = 0.008\nt = 0.012\nt = 0.016\n...\nt = 0.984\nt = 0.988\nt = 0.992\nt = 0.996\nt = 1.0\n()","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run a callback at certain times, you can at_times. Note that the specified times are rounded to the nearest timestep. ","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"printer = at_times([0.1, 0.5, 0.75]) do state\n    println(\"t = \", state.t)\nend","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> solve(prob, (0.0, 1.0); call=[printer])\nt = 0.1\nt = 0.5\nt = 0.752\n()","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Any amount of StateCallbacks can be passed to solve:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> foo = at_times([0.0, 0.5]) do state\n           println(\"foo \", state.t)\n       end;\n\njulia> bar = at_times(0.2:0.1:0.7) do state\n           println(\"bar \", state.t)\n       end;\n\njulia> solve(prob, (0.0, 1.0); call=[foo, bar])\nfoo 0.0\nbar 0.2\nbar 0.3\nbar 0.4\nfoo 0.5\nbar 0.5\nbar 0.6\nbar 0.7\n()","category":"page"},{"location":"getting-started/tutorial/#Quantities","page":"Tutorial","title":"Quantities","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Quantities module provides functions to retrieve various quantities from the state. For example, the lift and drag coefficients:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"using IBPM.Quantities\n\n# Initialize lift and drag functions for the current problem\nlift_coef = LiftCoef(prob)\ndrag_coef = DragCoef(prob)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"lift_coef and drag_coef are now functions of state. We can use them in a callback to display the lift and drag coefficients at various times:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"printer = at_times([0.4, 0.5, 0.6]) do state\n    t = state.t\n    CL = lift_coef(state)\n    CD = drag_coef(state)\n    \n    @show t CL CD # show the time, lift, and drag\n    println() # add a blank line\nend;","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> solve(prob, (0.0, 1.0); call=[printer])\nt = 0.4\nCL = [0.15178098433850362, -0.15178098294484957]\nCD = [1.9657374042287432, 1.9657374049036318]\n\nt = 0.5\nCL = [0.09809539226174821, -0.0980953807487285]\nCD = [1.9616546848510217, 1.9616546911652222]\n\nt = 0.6\nCL = [0.0338480211407524, -0.03384797778806221]\nCD = [1.9843193605706249, 1.9843193890137298]\n\n()","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that lift_coef and drag_coef return arrays of values, one for each body specified.","category":"page"},{"location":"getting-started/tutorial/#Saving-Results","page":"Tutorial","title":"Saving Results","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Each time we called solve, it returned the empty tuple (). This is because we did not specify any quantities to save. We can specify callbacks to save with the save keyword argument. Any return values from the given StateCallbacks are aggregated during the simulation.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> state_time = at_times([0.0, 0.1, 0.5]) do state\n           return state.t\n       end;\n\njulia> solve(prob, (0.0, 1.0); save=())\n()\n\njulia> solve(prob, (0.0, 1.0); save=(state_time,))\n([0.0, 0.1, 0.5],)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, the result array has element type Any. To specify the type of values returned by a callback, pass it as an additional argument:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> state_time = at_times([0.0, 0.1, 0.5], Float64) do state\n           return state.t\n       end;\n\njulia> times, = solve(prob, (0.0, 1.0); save=(state_time,))\n([0.0, 0.1, 0.5],)\n\njulia> eltype(times)\nFloat64","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the lift_coef and drag_coef functions defined earlier, we can save the lift and drag:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"get_lift = at_times(0.1:0.3:1, Float64) do state\n    return lift_coef(state)[1] # get the lift coefficient of the first body\nend\nget_drag = at_times(0.1:0.3:1, Float64) do state\n    return drag_coef(state)[1] # get the drag coefficient of the first body\nend","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> (CL, CD) = solve(prob, (0.0, 1.0); save=(get_lift, get_drag));\n\njulia> CL\n4-element IBPM.StateResult{Float64}:\n  0.24192790813515172\n  0.15178098433850362\n -0.03935393884308133\n -0.29355757293462786\n\njulia> CD\n4-element IBPM.StateResult{Float64}:\n 2.780251707849143\n 1.9657374042287432\n 2.017601519175688\n 2.105254970163017","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"If you are saving multiple quantities, you can use a named tuple to keep track of the fields.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"save = (\n    time=at_times(state -> state.t, [0.1, 0.2], Float64),\n    lift=at_times(state -> lift_coef(state)[1], [0.3, 0.4], Float64),\n    drag=at_times(state -> drag_coef(state)[1], [0.3, 0.4], Float64),\n)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> results = solve(prob, (0.0, 1.0); save=save)\n(time = [0.1, 0.2], lift = [0.1937292945096216, 0.15178098433850362], drag = [2.0271052799736538, 1.9657374042287432])\n\njulia> results.drag[2]\n1.9657374042287432","category":"page"},{"location":"getting-started/tutorial/#Plotting","page":"Tutorial","title":"Plotting","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"IBPM comes with two built-in plotting recipes for the Plots package: fluidplot and bodyplot. The former is essentially a heatmap with sensible defaults, and the latter plots bodies.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"To plot some function or array over a range of x coordinates x and y coordinates y, the syntax is:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"fluidplot(x, y, f)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"Keyword arguments are interpreted by Plots, so you can do something like:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"fluidplot(x, y, f; colorbar=false, title=\"foo\")","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"To plot a body, the syntax is","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"bodyplot(points)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can easily get points with the BodyPoints quantity from IBPM.Quantities module.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"using IBPM.Quantities\n\nvorticity = Vorticity(prob)\nbodypoints = BodyPoints(prob)\n\nT = 5.0\nthe_last_state = at_times(identity, [T])\n(last_state,), = solve(prob, (0.0, T); save=(the_last_state,))\n\nx = range(-1, 3, step=dx)\ny = range(-2, 2, step=dx)\n\nfluidplot(x, y, vorticity(last_state))\nbodyplot!(bodypoints(last_state)) # modify the plot (!)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Vorticity Contour Plot)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"A simple animation can be made with Plots' Animation.","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"T = 15.0\nanim = Animation()\n\nsave_anim = at_times(range(0, T, 150)) do state\n    fluidplot(x, y, vorticity(state); clims=(-5, 5), size=(512, 512))\n    bodyplot!(bodypoints(state))\n    \n    frame(anim) # Save an animation frame\nend\n\nsolve(prob, (0.0, T); call=[save_anim])\n\ngif(anim)","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Vorticity Animation)","category":"page"},{"location":"getting-started/tutorial/#Grid-Quantities","page":"Tutorial","title":"Grid Quantities","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, quantities that apply over a grid like Vorticity return interpolation functions. To get the raw arrays, specify kind=Discrete() as a keyword argument:","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> grid_vorticity = Vorticity(prob; kind=Discrete());\n\njulia> grid_vorticity(last_state)\n199×199×3 Array{Float64, 3}:\n[:, :, 1] =\n 1.45597e-14  …  -1.41273e-14\n 1.4306e-14      -1.33512e-14\n 1.38929e-14     -1.27107e-14\n ⋮            ⋱  \n 0.00363365      -0.00385906\n 0.00305794      -0.00338663\n\n[:, :, 2] =\n -1.10463e-14  …  1.05124e-14\n -1.2348e-14      1.18209e-14\n -1.19748e-14     1.14585e-14\n  ⋮            ⋱  \n -1.06824e-14     1.55079e-14\n -1.03108e-14     1.50663e-14\n\n[:, :, 3] =\n  8.24782e-16  …  -7.9071e-16\n -6.53323e-16      7.31455e-16\n -2.35906e-15      2.34558e-15\n  ⋮            ⋱  \n  9.93147e-15     -9.60593e-15\n  1.77592e-14     -1.81424e-14","category":"page"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"The last dimension corresponds to the 3 subdomains we specified earlier. To get the coordinates that these values apply to, see gridranges.","category":"page"},{"location":"getting-started/tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"","category":"section"},{"location":"getting-started/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are more examples in the examples directory of the IBPM repository. Among other things, they show how to specify moving bodies.","category":"page"},{"location":"manual/interface-coupling/interface-coupling/","page":"interface-coupling.jl","title":"interface-coupling.jl","text":"Modules = [IBPM]\nPages = [\"interface-coupling.jl\"]","category":"page"},{"location":"manual/interface-coupling/interface-coupling/#IBPM.setup_reg-Union{Tuple{T}, Tuple{T, Vector{<:IBPM.Body}}} where T<:IBPM.Grid","page":"interface-coupling.jl","title":"IBPM.setup_reg","text":"Return the interpolation matrix E, which interpolates flow quantities to the immersed boundary.  This depends on the position of the body points, but not their velocities\n\nThe transpose of E is the regularization matrix which smears quantities from the IB to the flow domain.\n\n\n\n\n\n","category":"method"},{"location":"manual/interface-coupling/interface-coupling/#IBPM.δh-Tuple{Any, Any, Any}","page":"interface-coupling.jl","title":"IBPM.δh","text":"δh( rf, rb , dr )\n\nDiscrete delta function used to relate flow to structure quantities\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/","page":"nonlinlear.jl","title":"nonlinlear.jl","text":"Modules = [IBPM]\nPages = [\"nonlinear.jl\"]","category":"page"},{"location":"manual/fluid-operators/nonlinear/#IBPM.avg_flux-Tuple{IBPM.IBState, IBPM.LinearizedIBProblem}","page":"nonlinlear.jl","title":"IBPM.avg_flux","text":"Compute average fluxes across cells in linearized problem (no freestream)\n\nReturn views into working memory prob.model.work.q2\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.avg_flux-Tuple{IBPM.IBState, IBProblem}","page":"nonlinlear.jl","title":"IBPM.avg_flux","text":"Compute average fluxes across cells\n\nReturn views into working memory prob.model.work.q2\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.direct_product!-Tuple{Any, Any, Any, Any, Any, IBPM.LinearizedIBProblem}","page":"nonlinlear.jl","title":"IBPM.direct_product!","text":"direct_product!(fq, Q, Γ, prob::LinearizedIBProblem, lev)\n\nCompute the base flow advection terms for the linear problem.\n\nNeeds FOUR flux-shaped arrays from working memory (one extra compared to nonlinear solver)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.direct_product!-Tuple{Any, Any, Any, Any, Any, IBProblem}","page":"nonlinlear.jl","title":"IBPM.direct_product!","text":"direct_product!(fq, Q, Γ, prob::IBProblem, lev)\n\nGather the product used in computing advection term\n\nNote that the grid level lev isn't used here, but is required for    the linearized version\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.direct_product_loops!-Tuple{Any, Any, Any, Any, IBPM.AbstractIBProblem}","page":"nonlinlear.jl","title":"IBPM.direct_product_loops!","text":"directproductloops!(fq, Q, Γ, Γbc, prob)\n\nHelper function to compute the product of Q and Γ so that the advective    term is ∇⋅fq\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.nl_avg!-NTuple{7, Any}","page":"nonlinlear.jl","title":"IBPM.nl_avg!","text":"fq = scale(Q1Γ1 + Q2*Γ2) \n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.nonlinear!-Tuple{AbstractArray, IBPM.IBState, AbstractArray, Int64, IBPM.AbstractIBProblem}","page":"nonlinlear.jl","title":"IBPM.nonlinear!","text":"nonlinear!(nonlin, state, Γbc, lev, prob::IBProblem)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-operators/nonlinear/#IBPM.nonlinear_OLD!-Tuple{AbstractArray, IBPM.IBState, AbstractArray, Int64, IBProblem}","page":"nonlinlear.jl","title":"IBPM.nonlinear_OLD!","text":"nonlinear!(nonlin, state, Γbc, lev, prob)\n\n\n\n\n\n","category":"method"},{"location":"manual/fluid-domain/fluid-domain/","page":"fluid-domain.jl","title":"fluid-domain.jl","text":"Modules = [IBPM]\nPages = [\"fluid-domain.jl\"]","category":"page"},{"location":"manual/fluid-domain/fluid-domain/#IBPM.Grid","page":"fluid-domain.jl","title":"IBPM.Grid","text":"A collection of types of grids used to discretize and solve the linear system. Types of flow grids include:\n\nMultiGrid\nTODO: Quadtree\n\n\n\n\n\n","category":"type"},{"location":"manual/fluid-domain/fluid-domain/#IBPM.MultiGrid","page":"fluid-domain.jl","title":"IBPM.MultiGrid","text":"MultiGrid <: Grid\n\nA type of Grid which uses a hierarchy of spacial discretizations to recursively solve until the solution converges.  While faster than brute force solving large linear systems, MultiGrid typically uses relatively high memory allocation.\n\n\n\n\n\n","category":"type"},{"location":"manual/fluid-domain/fluid-domain/#IBPM.MultiGrid-Tuple{Float64, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}","page":"fluid-domain.jl","title":"IBPM.MultiGrid","text":"MultiGrid(\n    h::Float64,\n    boundary::NTuple{2, Tuple{Float64, Float64}};\n    mg::Int = 1\n)\n\nConstructor for struct MultiGrid. Returns an instance of struct MultiGrid, see Main.IBPM.MultiGrid.\n\nArugments\n\nh::Float64: Grid spacing.\nboundary::NTuple{2, Tuple{Float64, Float64}}: Tuple defining the boundaries of the domain.\nmg::Int: Number of domains in MultiGrid. Default: 1.\n\n\n\n\n\n","category":"method"},{"location":"manual/structure-domain/structure-domain/","page":"structure-domain.jl","title":"structure-domain.jl","text":"Modules = [IBPM]\nPages = [\"structure-domain.jl\"]","category":"page"},{"location":"manual/structure-domain/motion-types/","page":"motion-types.jl","title":"motion-types.jl","text":"Modules = [IBPM]\nPages = [\"motion-types.jl\"]","category":"page"},{"location":"manual/structure-domain/motion-types/#IBPM.Motion","page":"motion-types.jl","title":"IBPM.Motion","text":"Types of motion a body can undergo\n\n\n\n\n\n","category":"type"},{"location":"manual/structure-domain/motion-types/#IBPM.Static","page":"motion-types.jl","title":"IBPM.Static","text":"Fixed body - no motion\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/problem-types/","page":"problem-types.jl","title":"problem-types.jl","text":"Modules = [IBPM]\nPages = [\"problem-types.jl\"]","category":"page"},{"location":"manual/pre-processing/problem-types/#IBPM.AbstractIBProblem","page":"problem-types.jl","title":"IBPM.AbstractIBProblem","text":"IBProblem has the info of IBModel as well as the problem structure (e.g., the explicit time stepping scheme and information about the implicit treatment via the A and B matrices and their inverses).\n\nMaybe some opportunity for restructuring...\n\nLooking towards possible compatibility with DifferentialEquations.jl, this         would be similar to the ODEProblem\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/problem-types/#IBPM.IBProblem","page":"problem-types.jl","title":"IBPM.IBProblem","text":"IBProblem <: AbstractIBProblem\n\nInitialize the problem structure (matrices used, bodies and simulation parameters, time steppping scheme, ...)\n\nNote: the scheme actually speaks to the terms that are explicitly treated. This is a projection method the directly enforces the no-slip condition, so some terms are implicitly treated. This information is not contained in scheme, but in the A, Ainv, B, and Binv matrices.\n\n\n\nIBProblem(\n    grid::Grid,\n    bodies::Vector{<:Body{M}} where M,\n    freestream = t -> (0.0, 0.0);\n    Re::Float64,\n    dt::Float64,\n)\n\nArguments\n\ngrid: Discretization of the fluid domain.\nbodies: The bodies to simulate.\nfreestream: The freestream velocity as a function of time. freestream(t) returns a       tuple of each velocity component at t. Defaults to zero.\nRe: Reynolds number.\ndt: The time stepsize.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/problem-types/#IBPM.LinearizedIBProblem","page":"problem-types.jl","title":"IBPM.LinearizedIBProblem","text":"LinearizedIBProblem <: AbstractIBProblem\n\nCreate a linearized problem from the base_state and associated IBProblem\n\nNOTE: The freestream value in the nonlinear IBProblem will be incorrect for the linearized case, but this field is not used in base_flux!(..., prob::LinearizedIBProblem, ...)\n\nModified IBProblem to include base state.  Only modification to the code is the direct product called by the nonlinear! function\n\nConstructor\n\nLinearizedIBProblem(\n    base_state::IBState,\n    base_prob::IBProblem,\n    dt::Float64\n)\n\nArugments\n\nbase_state::IBState: \nbase_prob::IBProblem: \ndt::Float64: Time stepping interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/problem-types/#IBPM.grid_of","page":"problem-types.jl","title":"IBPM.grid_of","text":"grid_of(x)\n\nThe Grid cooresponding to a problem or model.\n\n\n\n\n\n","category":"function"},{"location":"manual/pre-processing/problem-types/#IBPM.gridstep","page":"problem-types.jl","title":"IBPM.gridstep","text":"gridstep(x)\n\nThe minimum grid step size of a problem, model, or grid.\n\n\n\n\n\n","category":"function"},{"location":"manual/pre-processing/problem-types/#IBPM.model_of","page":"problem-types.jl","title":"IBPM.model_of","text":"model_of(problem)\n\nThe SolnModel corresponding to problem.\n\n\n\n\n\n","category":"function"},{"location":"manual/pre-processing/problem-types/#IBPM.motions_of","page":"problem-types.jl","title":"IBPM.motions_of","text":"motions_of(x)\n\nThe Motion subtype corresponding to a problem or model.\n\n\n\n\n\n","category":"function"},{"location":"manual/pre-processing/problem-types/#IBPM.scheme_of","page":"problem-types.jl","title":"IBPM.scheme_of","text":"scheme_of(problem)\n\nThe ExplicitScheme corresponding to problem.\n\n\n\n\n\n","category":"function"},{"location":"manual/pre-processing/problem-types/#IBPM.timestep","page":"problem-types.jl","title":"IBPM.timestep","text":"timestep(x)\n\nThe time step size of a problem or scheme.\n\n\n\n\n\n","category":"function"},{"location":"manual/timestepping/quantities/","page":"quantities.jl","title":"quantities.jl","text":"Modules = [IBPM]\nPages = [\"quantities.jl\"]","category":"page"},{"location":"#IBPM.jl","page":"Home","title":"IBPM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia CFD package based on the Immersed Boundary Projection Method (IBPM) from Taira & Colonius (2007), with multigrid method from Colonius & Taira (2008).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Oscillating plate)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oscillating plate at Reynolds number 200. See \"Examples\" folder for other example cases.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bodies: the bodies are a collection of boundary points at which the no-slip conditions are enforced, along with a Motion (currently only Static \"motion\" is supported).  The structure-domain/sample-bodies.jl file also has utilities to make a couple of basic bodies (a cylinder and 4-digit NACA airfoils, for instance).\nModel: the model is a structure to hold information about the domain - the grid, an array of bodies, pre-allocated working memory, and any matrices and operators that can be precomputed.  In other words, everything short of the time discretization belongs to the Model\nProblem: Ideally this could interface with the DifferentialEquations.jl package eventually, so a \"IBProblem\" is defined in the same spirit as the \"ODEProblem\".  This combines a Model with precomputed operators relevant for advancing the state.\nState: This is just a collection of pre-allocated arrays to store the vorticity, streamfunction, velocity flux, and body forces (including lift and drag).  It also has storage for the \"memory\" of the multi-step scheme for the nonlinear terms.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once a Problem and State are defined, the basic time-stepping is to just call advance!(state, prob, t).  There are also some helpful functions in ibpm.jl to run the full simulation, for instance to save a GIF of the solution.","category":"page"},{"location":"#Current-Status-(4/22/21)","page":"Home","title":"Current Status (4/22/21)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently only rigid bodies have been implemented, although a single moving body can be simulated by moving the grid (a \"body-fixed\" reference frame, although the equations are in the inertial lab frame).  The reference cases (see the benchmarks folder) match the Fortran implementation to within 10^-6 relative error, but with an average of about 40% speedup (and slightly more compared to the C++ code).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The next plans include arbitrary motion (with a fixed grid), parallelization, and adding an FSI solver for flexible bodies.","category":"page"},{"location":"manual/plotting/plotting-utils/","page":"plotting-utils.jl","title":"plotting-utils.jl","text":"Modules = [IBPM]\nPages = [\"plotting-utils.jl\"]","category":"page"},{"location":"manual/pre-processing/state-types/","page":"state-types.jl","title":"state-types.jl","text":"Modules = [IBPM]\nPages = [\"state-types.jl\"]","category":"page"},{"location":"manual/pre-processing/state-types/#IBPM.IBState-Tuple{Any, Number}","page":"state-types.jl","title":"IBPM.IBState","text":"Randomly initialize the vorticity of the IBState\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#IBPM.IBState-Tuple{Any}","page":"state-types.jl","title":"IBPM.IBState","text":"Construct empty state from AbstractIBProblem\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#IBPM.State","page":"state-types.jl","title":"IBPM.State","text":"State variables (stores everything needed for time stepping)\n\n\n\n\n\n","category":"type"},{"location":"manual/pre-processing/state-types/#Base.:*-Union{Tuple{V}, Tuple{T}, Tuple{T, IBPM.IBState{V}}} where {T<:Number, V<:Number}","page":"state-types.jl","title":"Base.:*","text":"multiply v with a scalar α, which can be of a different scalar type\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#Base.copy!-Union{Tuple{T}, Tuple{IBPM.IBState{T}, IBPM.IBState{T}}} where T","page":"state-types.jl","title":"Base.copy!","text":"Copy all fields of IBState v to w\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#Base.length-Tuple{IBPM.IBState}","page":"state-types.jl","title":"Base.length","text":"Define the length of a state as the size of the circulation vector Γ\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#LinearAlgebra.axpby!-Tuple{Number, IBPM.IBState, Number, IBPM.IBState}","page":"state-types.jl","title":"LinearAlgebra.axpby!","text":"store in w the result of αv + βw\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#LinearAlgebra.axpy!-Tuple{Number, IBPM.IBState, IBPM.IBState}","page":"state-types.jl","title":"LinearAlgebra.axpy!","text":"store in w the result of α*v + w\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#LinearAlgebra.dot-Tuple{IBPM.IBState, IBPM.IBState}","page":"state-types.jl","title":"LinearAlgebra.dot","text":"compute the inner product (in kinetic energy) of two states\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#LinearAlgebra.mul!-Tuple{IBPM.IBState, IBPM.IBState, Number}","page":"state-types.jl","title":"LinearAlgebra.mul!","text":"Out of place scalar multiplication; multiply vector v with scalar α and store the result in w\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#LinearAlgebra.norm-Tuple{IBPM.IBState}","page":"state-types.jl","title":"LinearAlgebra.norm","text":"compute the 2-norm (kinetic energy) of a state\n\n\n\n\n\n","category":"method"},{"location":"manual/pre-processing/state-types/#LinearAlgebra.rmul!-Tuple{IBPM.IBState, Number}","page":"state-types.jl","title":"LinearAlgebra.rmul!","text":"In-place scalar multiplication of v with α; in particular with α = false, v is the corresponding zero vector\n\n\n\n\n\n","category":"method"}]
}
